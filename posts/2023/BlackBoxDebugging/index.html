<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Black Box Debugging iOS Binaries</title>
  <link href="https://unpkg.com/prismjs@1.20.0/themes/prism-okaidia.css" rel="stylesheet">
  <link rel="stylesheet" href="/style.css"/>
  <link rel="stylesheet" href="pico.min.css">
  <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
</head>
<body>
  <nav class="container-fluid">
  <ul>
    <li>
      <a href="/" class="contrast"><strong>Ashley Arthur</strong></a
      >
    </li>
  </ul>

  <ul>
    <li><a href="/archive">Archive</a></li>
    <li><a href="https://github.com/ash30">Github</a></li>
    <li><a href="https://uk.linkedin.com/in/ash30">Linkedin</a></li>
  </ul>
  </nav>
  <main class="container">
  	
<hgroup>
<h1>

Black Box Debugging iOS Binaries

</h1>
	<time datetime="2023-09-18">18 September 2023</time>
</hgroup>

  	<p>Like many other companies in the space, Vonage relies on libwebrtc in it's client-facing voice SDK. Just as I was going to take some leave, we had a peculiar issue pop up when we tried what we thought was a routine upgrade... our SDK was now causing App store uploads to fail!</p>
<p>Ah, the joys of iOS development! For the uninitiated, getting your app onto the App Store involves navigating a series of infamous checks. One of the hurdles is a series of static analysis apple subjects your binary to once its been uploaded. Usually, Apple is on the ball, catching issues during compile time or, worst case, somewhere in the debug cycle. But sometimes, the checks come post-build. They are there to ensure system resources aren't abused in weird and wonderful ways. Unfortunately if you rely on 3rd party code like libwebrtc, you're on the hook if any of their code triggers a failure and you'll need to figure out what's changed.</p>
<p>Well here's the trick: System APIs are dynamically linked on iOS<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> so you can do a pretty good quick and dirty audit by viewing the unresolved symbols left in the app binary. Unzip the ipa and fire up the <code>nm</code> tool and you'll get output like the following.</p>
<pre><code>&gt;&gt; nm app
 U _$s5UIKit17UIApplicationMainys5Int32VAD_SpySpys4Int8VGGSgSSSgAJtF
 U _$sBOWV
 U _$sSS10FoundationE19_bridgeToObjectiveCSo8NSStringCyF
 U _$sSS10FoundationE36_unconditionallyBridgeFromObjectiveCySSSo8NSStringCSgFZ
 U _$ss11CommandLineO10unsafeArgvSpySpys4Int8VGSgGvgZ
 U _$ss11CommandLineO4argcs5Int32VvgZ
 U _AVAudioSessionCategoryPlayAndRecord
 U _AVAudioSessionInterruptionNotification
 U _AVAudioSessionInterruptionOptionKey
 U _AVAudioSessionInterruptionTypeKey
 U _AVAudioSessionMediaServicesWereLostNotification
 U _AVAudioSessionMediaServicesWereResetNotification
 U _AVAudioSessionModeDefault
 U _AVAudioSessionModeVoiceChat
 ... 
</code></pre>
<p>God Bless Objective C's non mangled symbols, they make reading through and matching api usage pretty trivial. In the end I was able to simply diff the output for different versions of the SDK and find the offending the symbol. Then it was a case of finding its usage within libwebrtc and working out an internal patch to ifdef it out when required.</p>
<p>Phew! All in a days work (quite literally!)</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>I assume its the case on most platforms...? <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
 
  </main>

</body>
